/* eslint-disable */
/**
 * Generated by orval üç∫
 * Do not edit manually. Run "npm run generate-client" instead.
 * Connector Manifest schema
 * OpenAPI spec version: 1.0.0
 */
export type RemoveFieldsAllOf = {
  field_pointers: string[][];
};

/**
 * 
    Implementations of this class define transformations that can be applied to records of a stream.
    
 */
export interface RecordTransformation {
  [key: string]: any;
}

/**
 * 
    A transformation which removes fields from a record. The fields removed are designated using FieldPointers.
    During transformation, if a field or any of its parents does not exist in the record, no error is thrown.

    If an input field pointer references an item in a list (e.g: ["k", 0] in the object {"k": ["a", "b", "c"]}) then
    the object at that index is set to None rather than being not entirely removed from the list. TODO change this behavior.

    It's possible to remove objects nested in lists e.g: removing [".", 0, "k"] from {".": [{"k": "V"}]} results in {".": [{}]}

    Usage syntax:

    ```yaml
        my_stream:
            <other parameters..>
            transformations:
                - type: RemoveFields
                  field_pointers:
                    - ["path", "to", "field1"]
                    - ["path2"]
    ```

    Attributes:
        field_pointers (List[FieldPointer]): pointers to the fields that should be removed
    
 */
export type RemoveFields = RecordTransformation & RemoveFieldsAllOf;

/**
 * Defines the field to add on a record
 */
export interface ParsedAddFieldDefinition {
  path: string[];
  value: InterpolatedString;
}

export type AddedFieldDefinitionValue = InterpolatedString | string;

/**
 * Defines the field to add on a record
 */
export interface AddedFieldDefinition {
  path: string[];
  value: AddedFieldDefinitionValue;
}

export type AddFieldsAllOf = {
  fields: AddedFieldDefinition[];
  _parsed_fields?: ParsedAddFieldDefinition[];
};

/**
 * 
    Transformation which adds field to an output record. The path of the added field can be nested. Adding nested fields will create all
    necessary parent objects (like mkdir -p). Adding fields to an array will extend the array to that index (filling intermediate
    indices with null values). So if you add a field at index 5 to the array ["value"], it will become ["value", null, null, null, null,
    "new_value"].


    This transformation has access to the following contextual values:
        record: the record about to be output by the connector
        config: the input configuration provided to a connector
        stream_state: the current state of the stream
        stream_slice: the current stream slice being read



    Examples of instantiating this transformation via YAML:
    - type: AddFields
      fields:
        # hardcoded constant
        - path: ["path"]
          value: "static_value"

        # nested path
        - path: ["path", "to", "field"]
          value: "static"

        # from config
        - path: ["shop_id"]
          value: "{{ config.shop_id }}"

        # from state
        - path: ["current_state"]
          value: "{{ stream_state.cursor_field }}" # Or {{ stream_state['cursor_field'] }}

        # from record
        - path: ["unnested_value"]
          value: {{ record.nested.field }}

        # from stream_slice
        - path: ["start_date"]
          value: {{ stream_slice.start_date }}

        # by supplying any valid Jinja template directive or expression https://jinja.palletsprojects.com/en/3.1.x/templates/#
        - path: ["two_times_two"]
          value: {{ 2 * 2 }}

    Attributes:
        fields (List[AddedFieldDefinition]): A list of transformations (path and corresponding value) that will be added to the record
    
 */
export type AddFields = RecordTransformation & AddFieldsAllOf;

/**
 * Loads a schema from the manifest, if provided.
 */
export interface InlineSchemaLoader {
  [key: string]: any;
}

export type DefaultSchemaLoaderAllOfConfig = { [key: string]: any };

export type DefaultSchemaLoaderAllOf = {
  config: DefaultSchemaLoaderAllOfConfig;
};

/**
 * Describes a stream's schema
 */
export interface SchemaLoader {
  [key: string]: any;
}

/**
 * 
    Loads a schema from the default location or returns an empty schema for streams that have not defined their schema file yet.

    Attributes:
        config (Config): The user-provided configuration as specified by the source's spec
        options (Mapping[str, Any]): Additional arguments to pass to the string interpolation if needed
    
 */
export type DefaultSchemaLoader = SchemaLoader & DefaultSchemaLoaderAllOf;

export type JsonFileSchemaLoaderAllOfFilePath = InterpolatedString | string;

export type JsonFileSchemaLoaderAllOfConfig = { [key: string]: any };

export type JsonFileSchemaLoaderAllOf = {
  config: JsonFileSchemaLoaderAllOfConfig;
  file_path?: JsonFileSchemaLoaderAllOfFilePath;
};

/**
 * 
    Loads the schema from a json file

    Attributes:
        file_path (Union[InterpolatedString, str]): The path to the json file describing the schema
        name (str): The stream's name
        config (Config): The user-provided configuration as specified by the source's spec
        options (Mapping[str, Any]): Additional arguments to pass to the string interpolation if needed
    
 */
export type JsonFileSchemaLoader = SchemaLoader & JsonFileSchemaLoaderAllOf;

/**
 * 
    Responsible for fetching a stream's records from an HTTP API source.
    
 */
export interface Retriever {
  [key: string]: any;
}

/**
 * 
    Describes how to create a stream slice from a parent stream

    stream: The stream to read records from
    parent_key: The key of the parent stream's records that will be the stream slice key
    stream_slice_field: The stream slice key
    request_option: How to inject the slice value on an outgoing HTTP request
    
 */
export interface ParentStreamConfig {
  stream: unknown;
  parent_key: string;
  stream_slice_field: string;
  request_option?: RequestOption;
}

export type SubstreamSlicerAllOf = {
  parent_stream_configs: ParentStreamConfig[];
};

/**
 * 
    Stream slicer that iterates over the parent's stream slices and records and emits slices by interpolating the slice_definition mapping
    Will populate the state with `parent_stream_slice` and `parent_record` so they can be accessed by other components

    Attributes:
        parent_stream_configs (List[ParentStreamConfig]): parent streams to iterate over and their config
    
 */
export type SubstreamSlicer = StreamSlicer & SubstreamSlicerAllOf;

export type SingleSliceAllOf = { [key: string]: any };

export type ListStreamSlicerAllOfConfig = { [key: string]: any };

export type ListStreamSlicerAllOfCursorField = InterpolatedString | string;

export type ListStreamSlicerAllOfSliceValues = string[] | string;

export type ListStreamSlicerAllOf = {
  slice_values: ListStreamSlicerAllOfSliceValues;
  cursor_field: ListStreamSlicerAllOfCursorField;
  config: ListStreamSlicerAllOfConfig;
  request_option?: RequestOption;
};

export type StreamSlicerAllOf = { [key: string]: any };

/**
 * 
    Slices the stream into a subset of records.
    Slices enable state checkpointing and data retrieval parallelization.

    The stream slicer keeps track of the cursor state as a dict of cursor_field -> cursor_value

    See the stream slicing section of the docs for more information.
    
 */
export type StreamSlicer = RequestOptionsProvider & StreamSlicerAllOf;

/**
 * Stream slicer returning only a single stream slice
 */
export type SingleSlice = StreamSlicer & SingleSliceAllOf;

/**
 * 
    Stream slicer that iterates over the values of a list
    If slice_values is a string, then evaluate it as literal and assert the resulting literal is a list

    Attributes:
        slice_values (Union[str, List[str]]): The values to iterate over
        cursor_field (Union[InterpolatedString, str]): The name of the cursor field
        config (Config): The user-provided configuration as specified by the source's spec
        request_option (Optional[RequestOption]): The request option to configure the HTTP request
    
 */
export type ListStreamSlicer = StreamSlicer & ListStreamSlicerAllOf;

export type MinMaxDatetimeMaxDatetime = InterpolatedString | string;

export type MinMaxDatetimeMinDatetime = InterpolatedString | string;

export type MinMaxDatetimeDatetime = InterpolatedString | string;

/**
 * 
    Compares the provided date against optional minimum or maximum times. If date is earlier than
    min_date, then min_date is returned. If date is greater than max_date, then max_date is returned.
    If neither, the input date is returned.

    The timestamp format accepts the same format codes as datetime.strfptime, which are
    all the format codes required by the 1989 C standard.
    Full list of accepted format codes: https://man7.org/linux/man-pages/man3/strftime.3.html

    Attributes:
        datetime (Union[InterpolatedString, str]): InterpolatedString or string representing the datetime in the format specified by `datetime_format`
        datetime_format (str): Format of the datetime passed as argument
        min_datetime (Union[InterpolatedString, str]): Represents the minimum allowed datetime value.
        max_datetime (Union[InterpolatedString, str]): Represents the maximum allowed datetime value.
    
 */
export interface MinMaxDatetime {
  datetime: MinMaxDatetimeDatetime;
  datetime_format?: string;
  _datetime_format?: string;
  min_datetime?: MinMaxDatetimeMinDatetime;
  max_datetime?: MinMaxDatetimeMaxDatetime;
}

/**
 * 
    Slices the stream over a datetime range.

    Given a start time, end time, a step function, and an optional lookback window,
    the stream slicer will partition the date range from start time - lookback window to end time.

    The step function is defined as a string of the form:
    `"<number><unit>"`

    where unit can be one of
    - years, y
    - months, m
    - weeks, w
    - days, d

    For example, "1d" will produce windows of 1 day, and "2w" windows of 2 weeks.

    The timestamp format accepts the same format codes as datetime.strfptime, which are
    all the format codes required by the 1989 C standard.
    Full list of accepted format codes: https://man7.org/linux/man-pages/man3/strftime.3.html

    Attributes:
        start_datetime (Union[MinMaxDatetime, str]): the datetime that determines the earliest record that should be synced
        end_datetime (Union[MinMaxDatetime, str]): the datetime that determines the last record that should be synced
        step (str): size of the timewindow
        cursor_field (Union[InterpolatedString, str]): record's cursor field
        datetime_format (str): format of the datetime
        config (Config): connection config
        start_time_option (Optional[RequestOption]): request option for start time
        end_time_option (Optional[RequestOption]): request option for end time
        stream_state_field_start (Optional[str]): stream slice start time field
        stream_state_field_end (Optional[str]): stream slice end time field
        lookback_window (Optional[InterpolatedString]): how many days before start_datetime to read data for
    
 */
export type DatetimeStreamSlicer = StreamSlicer & DatetimeStreamSlicerAllOf;

export type DatetimeStreamSlicerAllOfLookbackWindow = InterpolatedString | string;

export type _DatetimeStreamSlicerAllOfCursorEnd = { [key: string]: any };

export type _DatetimeStreamSlicerAllOfCursor = { [key: string]: any };

export type DatetimeStreamSlicerAllOfConfig = { [key: string]: any };

export type DatetimeStreamSlicerAllOfCursorField = InterpolatedString | string;

export type DatetimeStreamSlicerAllOfEndDatetime = MinMaxDatetime | string;

export type DatetimeStreamSlicerAllOfStartDatetime = MinMaxDatetime | string;

export type DatetimeStreamSlicerAllOf = {
  start_datetime: DatetimeStreamSlicerAllOfStartDatetime;
  end_datetime: DatetimeStreamSlicerAllOfEndDatetime;
  step: string;
  cursor_field: DatetimeStreamSlicerAllOfCursorField;
  datetime_format: string;
  config: DatetimeStreamSlicerAllOfConfig;
  _cursor?: _DatetimeStreamSlicerAllOfCursor;
  _cursor_end?: _DatetimeStreamSlicerAllOfCursorEnd;
  start_time_option?: RequestOption;
  end_time_option?: RequestOption;
  stream_state_field_start?: string;
  stream_state_field_end?: string;
  lookback_window?: DatetimeStreamSlicerAllOfLookbackWindow;
};

export type CartesianProductStreamSlicerAllOfStreamSlicersItem =
  | CartesianProductStreamSlicer
  | DatetimeStreamSlicer
  | ListStreamSlicer
  | SingleSlice
  | SubstreamSlicer;

export type CartesianProductStreamSlicerAllOf = {
  stream_slicers: CartesianProductStreamSlicerAllOfStreamSlicersItem[];
};

/**
 * 
    Stream slicers that iterates over the cartesian product of input stream slicers
    Given 2 stream slicers with the following slices:
    A: [{"i": 0}, {"i": 1}, {"i": 2}]
    B: [{"s": "hello"}, {"s": "world"}]
    the resulting stream slices are
    [
        {"i": 0, "s": "hello"},
        {"i": 0, "s": "world"},
        {"i": 1, "s": "hello"},
        {"i": 1, "s": "world"},
        {"i": 2, "s": "hello"},
        {"i": 2, "s": "world"},
    ]

    Attributes:
        stream_slicers (List[StreamSlicer]): Underlying stream slicers. The RequestOptions (e.g: Request headers, parameters, etc..) returned by this slicer are the combination of the RequestOptions of its input slicers. If there are conflicts e.g: two slicers define the same header or request param, the conflict is resolved by taking the value from the first slicer, where ordering is determined by the order in which slicers were input to this composite slicer.
    
 */
export type CartesianProductStreamSlicer = StreamSlicer & CartesianProductStreamSlicerAllOf;

export type NoPaginationAllOf = { [key: string]: any };

export type PaginatorAllOf = { [key: string]: any };

/**
 * 
    Defines the token to use to fetch the next page of records from the API.

    If needed, the Paginator will set request options to be set on the HTTP request to fetch the next page of records.
    If the next_page_token is the path to the next page of records, then it should be accessed through the `path` method
    
 */
export type Paginator = RequestOptionsProvider & PaginatorAllOf;

/**
 * 
    Pagination implementation that never returns a next page.
    
 */
export type NoPagination = Paginator & NoPaginationAllOf;

export type RequestOptionInjectInto = typeof RequestOptionInjectInto[keyof typeof RequestOptionInjectInto];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestOptionInjectInto = {
  request_parameter: "request_parameter",
  header: "header",
  path: "path",
  body_data: "body_data",
  body_json: "body_json",
} as const;

/**
 * 
    Describes an option to set on a request

    Attributes:
        inject_into (RequestOptionType): Describes where in the HTTP request to inject the parameter
        field_name (Optional[str]): Describes the name of the parameter to inject. None if option_type == path. Required otherwise.
    
 */
export interface RequestOption {
  inject_into: RequestOptionInjectInto;
  field_name?: string;
}

export type PageIncrementAllOf = {
  page_size: number;
  start_from_page?: number;
};

export type OffsetIncrementAllOf = {
  page_size: number;
};

/**
 * 
    Defines how to get the next page token
    
 */
export interface PaginationStrategy {
  [key: string]: any;
}

/**
 * 
    Pagination strategy that returns the number of pages reads so far and returns it as the next page token

    Attributes:
        page_size (int): the number of records to request
        start_from_page (int): number of the initial page
    
 */
export type PageIncrement = PaginationStrategy & PageIncrementAllOf;

/**
 * 
    Pagination strategy that returns the number of records reads so far and returns it as the next page token

    Attributes:
        page_size (int): the number of records to request
    
 */
export type OffsetIncrement = PaginationStrategy & OffsetIncrementAllOf;

/**
 * 
    Pagination strategy that evaluates an interpolated string to define the next page token

    Attributes:
        page_size (Optional[int]): the number of records to request
        cursor_value (Union[InterpolatedString, str]): template string evaluating to the cursor value
        config (Config): connection config
        stop_condition (Optional[InterpolatedBoolean]): template string evaluating when to stop paginating
        decoder (Decoder): decoder to decode the response
    
 */
export type CursorPaginationStrategy = PaginationStrategy & CursorPaginationStrategyAllOf;

export type CursorPaginationStrategyAllOfStopCondition = InterpolatedBoolean | string;

export type CursorPaginationStrategyAllOfConfig = { [key: string]: any };

export type CursorPaginationStrategyAllOfCursorValue = InterpolatedString | string;

export type CursorPaginationStrategyAllOf = {
  cursor_value: CursorPaginationStrategyAllOfCursorValue;
  config: CursorPaginationStrategyAllOfConfig;
  page_size?: number;
  stop_condition?: CursorPaginationStrategyAllOfStopCondition;
  decoder?: JsonDecoder;
};

export type DefaultPaginatorAllOfUrlBase = InterpolatedString | string;

export type DefaultPaginatorAllOfConfig = { [key: string]: any };

export type DefaultPaginatorAllOfPaginationStrategy = CursorPaginationStrategy | OffsetIncrement | PageIncrement;

export type DefaultPaginatorAllOf = {
  pagination_strategy: DefaultPaginatorAllOfPaginationStrategy;
  config: DefaultPaginatorAllOfConfig;
  url_base: DefaultPaginatorAllOfUrlBase;
  decoder?: JsonDecoder;
  _token?: unknown;
  page_size_option?: RequestOption;
  page_token_option?: RequestOption;
};

/**
 * 
    Default paginator to request pages of results with a fixed size until the pagination strategy no longer returns a next_page_token

    Examples:
        1.
        * fetches up to 10 records at a time by setting the "limit" request param to 10
        * updates the request path with  "{{ response._metadata.next }}"
        ```
          paginator:
            type: "DefaultPaginator"
            page_size_option:
              inject_into: request_parameter
              field_name: limit
            page_token_option:
              option_type: path
            pagination_strategy:
              type: "CursorPagination"
              cursor_value: "{{ response._metadata.next }}"
              page_size: 10
        ```

        2.
        * fetches up to 5 records at a time by setting the "page_size" header to 5
        * increments a record counter and set the request parameter "offset" to the value of the counter
        ```
          paginator:
            type: "DefaultPaginator"
            page_size_option:
              inject_into: header
              field_name: page_size
            pagination_strategy:
              type: "OffsetIncrement"
              page_size: 5
            page_token_option:
              option_type: "request_parameter"
              field_name: "offset"
        ```

        3.
        * fetches up to 5 records at a time by setting the "page_size" request param to 5
        * increments a page counter and set the request parameter "page" to the value of the counter
        ```
          paginator:
            type: "DefaultPaginator"
            page_size_option:
              inject_into: request_parameter
              field_name: page_size
            pagination_strategy:
              type: "PageIncrement"
              page_size: 5
            page_token_option:
              option_type: "request_parameter"
              field_name: "page"
        ```
    Attributes:
        page_size_option (Optional[RequestOption]): the request option to set the page size. Cannot be injected in the path.
        page_token_option (RequestOption): the request option to set the page token
        pagination_strategy (PaginationStrategy): Strategy defining how to get the next page token
        config (Config): connection config
        url_base (Union[InterpolatedString, str]): endpoint's base url
        decoder (Decoder): decoder to decode the response
    
 */
export type DefaultPaginator = Paginator & DefaultPaginatorAllOf;

/**
 * 
    Responsible for translating an HTTP response into a list of records by extracting records from the response and optionally filtering
    records based on a heuristic.
    
 */
export interface HttpSelector {
  [key: string]: any;
}

export type RecordFilterConfig = { [key: string]: any };

/**
 * 
    Filter applied on a list of Records

    config (Config): The user-provided configuration as specified by the source's spec
    condition (str): The string representing the predicate to filter a record. Records will be removed if evaluated to False
    
 */
export interface RecordFilter {
  config: RecordFilterConfig;
  condition?: string;
}

/**
 * 
    Responsible for translating an HTTP response into a list of records by extracting records from the response.
    
 */
export interface RecordExtractor {
  [key: string]: any;
}

/**
 * 
    Decoder strategy to transform a requests.Response into a Mapping[str, Any]
    
 */
export interface Decoder {
  [key: string]: any;
}

export type JsonDecoderAllOf = { [key: string]: any };

/**
 * 
    Decoder strategy that returns the json-encoded content of a response, if any.
    
 */
export type JsonDecoder = Decoder & JsonDecoderAllOf;

export type DpathExtractorAllOfConfig = { [key: string]: any };

export type DpathExtractorAllOfFieldPointerItem = InterpolatedString | string;

export type DpathExtractorAllOf = {
  field_pointer: DpathExtractorAllOfFieldPointerItem[];
  config: DpathExtractorAllOfConfig;
  decoder?: JsonDecoder;
};

/**
 * 
    Record extractor that searches a decoded response over a path defined as an array of fields.

    If the field pointer points to an array, that array is returned.
    If the field pointer points to an object, that object is returned wrapped as an array.
    If the field pointer points to an empty object, an empty array is returned.
    If the field pointer points to a non-existing path, an empty array is returned.

    Examples of instantiating this transform:
    ```
      extractor:
        type: DpathExtractor
        field_pointer:
          - "root"
          - "data"
    ```

    ```
      extractor:
        type: DpathExtractor
        field_pointer:
          - "root"
          - "{{ options['field'] }}"
    ```

    ```
      extractor:
        type: DpathExtractor
        field_pointer: []
    ```

    Attributes:
        transform (Union[InterpolatedString, str]): Pointer to the field that should be extracted
        config (Config): The user-provided configuration as specified by the source's spec
        decoder (Decoder): The decoder responsible to transfom the response in a Mapping
    
 */
export type DpathExtractor = RecordExtractor & DpathExtractorAllOf;

export type RecordSelectorAllOf = {
  extractor: DpathExtractor;
  record_filter?: RecordFilter;
};

/**
 * 
    Responsible for translating an HTTP response into a list of records by extracting records from the response and optionally filtering
    records based on a heuristic.

    Attributes:
        extractor (RecordExtractor): The record extractor responsible for extracting records from a response
        record_filter (RecordFilter): The record filter responsible for filtering extracted records
    
 */
export type RecordSelector = HttpSelector & RecordSelectorAllOf;

export type RequesterAllOf = { [key: string]: any };

export type Requester = RequestOptionsProvider & RequesterAllOf;

/**
 * 
    Defines whether a request was successful and how to handle a failure.
    
 */
export interface ErrorHandler {
  [key: string]: any;
}

/**
 * 
    Extract time at which we can retry the request from response header
    and wait for the difference between now and that time

    Attributes:
        header (str): header to read wait time from
        min_wait (Optional[float]): minimum time to wait for safety
        regex (Optional[str]): optional regex to apply on the header to extract its value
    
 */
export type WaitUntilTimeFromHeaderBackoffStrategy = BackoffStrategy & WaitUntilTimeFromHeaderBackoffStrategyAllOf;

export type WaitUntilTimeFromHeaderBackoffStrategyAllOfRegex = InterpolatedString | string;

export type WaitUntilTimeFromHeaderBackoffStrategyAllOfMinWait = InterpolatedString | number | string;

export type WaitUntilTimeFromHeaderBackoffStrategyAllOfConfig = { [key: string]: any };

export type WaitUntilTimeFromHeaderBackoffStrategyAllOfHeader = InterpolatedString | string;

export type WaitUntilTimeFromHeaderBackoffStrategyAllOf = {
  header: WaitUntilTimeFromHeaderBackoffStrategyAllOfHeader;
  config: WaitUntilTimeFromHeaderBackoffStrategyAllOfConfig;
  min_wait?: WaitUntilTimeFromHeaderBackoffStrategyAllOfMinWait;
  regex?: WaitUntilTimeFromHeaderBackoffStrategyAllOfRegex;
};

export type WaitTimeFromHeaderBackoffStrategyAllOfConfig = { [key: string]: any };

export type WaitTimeFromHeaderBackoffStrategyAllOfHeader = InterpolatedString | string;

export type WaitTimeFromHeaderBackoffStrategyAllOf = {
  header: WaitTimeFromHeaderBackoffStrategyAllOfHeader;
  config: WaitTimeFromHeaderBackoffStrategyAllOfConfig;
  regex?: string;
};

export type ExponentialBackoffStrategyAllOfFactor = InterpolatedString | number | string;

export type ExponentialBackoffStrategyAllOfConfig = { [key: string]: any };

export type ExponentialBackoffStrategyAllOf = {
  config: ExponentialBackoffStrategyAllOfConfig;
  factor?: ExponentialBackoffStrategyAllOfFactor;
};

/**
 * 
    Backoff strategy defining how long to wait before retrying a request that resulted in an error.
    
 */
export interface BackoffStrategy {
  [key: string]: any;
}

/**
 * 
    Extract wait time from http header

    Attributes:
        header (str): header to read wait time from
        regex (Optional[str]): optional regex to apply on the header to extract its value
    
 */
export type WaitTimeFromHeaderBackoffStrategy = BackoffStrategy & WaitTimeFromHeaderBackoffStrategyAllOf;

/**
 * 
    Backoff strategy with an exponential backoff interval

    Attributes:
        factor (float): multiplicative factor
    
 */
export type ExponentialBackoffStrategy = BackoffStrategy & ExponentialBackoffStrategyAllOf;

export type ConstantBackoffStrategyAllOfConfig = { [key: string]: any };

export type ConstantBackoffStrategyAllOfBackoffTimeInSeconds = InterpolatedString | number | string;

export type ConstantBackoffStrategyAllOf = {
  backoff_time_in_seconds: ConstantBackoffStrategyAllOfBackoffTimeInSeconds;
  config: ConstantBackoffStrategyAllOfConfig;
};

/**
 * 
    Backoff strategy with a constant backoff interval

    Attributes:
        backoff_time_in_seconds (float): time to backoff before retrying a retryable request.
    
 */
export type ConstantBackoffStrategy = BackoffStrategy & ConstantBackoffStrategyAllOf;

/**
 * InterpolatedBoolean(condition: str, options: dataclasses.InitVar[typing.Mapping[str, typing.Any]])
 */
export interface InterpolatedBoolean {
  condition: string;
}

export type HttpResponseFilterErrorMessage = InterpolatedString | string;

export type HttpResponseFilterPredicate = InterpolatedBoolean | string;

export type HttpResponseFilterConfig = { [key: string]: any };

export type HttpResponseFilterAction = "SUCCESS" | "FAIL" | "IGNORE" | "RETRY" | string;

/**
 * 
    Filter to select HttpResponses

    Attributes:
        action (Union[ResponseAction, str]): action to execute if a request matches
        http_codes (Set[int]): http code of matching requests
        error_message_contains (str): error substring of matching requests
        predicate (str): predicate to apply to determine if a request is matching
        error_message (Union[InterpolatedString, str): error message to display if the response matches the filter
    
 */
export interface HttpResponseFilter {
  action: HttpResponseFilterAction;
  config: HttpResponseFilterConfig;
  http_codes?: number[];
  error_message_contains?: string;
  predicate?: HttpResponseFilterPredicate;
  error_message?: HttpResponseFilterErrorMessage;
}

export type DefaultErrorHandlerAllOfBackoffStrategiesItem =
  | ConstantBackoffStrategy
  | ExponentialBackoffStrategy
  | WaitTimeFromHeaderBackoffStrategy
  | WaitUntilTimeFromHeaderBackoffStrategy;

export type DefaultErrorHandlerAllOfConfig = { [key: string]: any };

export type DefaultErrorHandlerAllOf = {
  config: DefaultErrorHandlerAllOfConfig;
  response_filters?: HttpResponseFilter[];
  max_retries?: number;
  _max_retries?: number;
  backoff_strategies?: DefaultErrorHandlerAllOfBackoffStrategiesItem[];
};

/**
 * 
    Default error handler.

    By default, the handler will only retry server errors (HTTP 5XX) and too many requests (HTTP 429) with exponential backoff.

    If the response is successful, then return SUCCESS
    Otherwise, iterate over the response_filters.
    If any of the filter match the response, then return the appropriate status.
    If the match is RETRY, then iterate sequentially over the backoff_strategies and return the first non-None backoff time.

    Sample configs:

    1. retry 10 times
    `
        error_handler:
          max_retries: 10
    `
    2. backoff for 5 seconds
    `
        error_handler:
          backoff_strategies:
            - type: "ConstantBackoff"
              backoff_time_in_seconds: 5
    `
    3. retry on HTTP 404
    `
        error_handler:
          response_filters:
            - http_codes: [404]
              action: RETRY
    `
    4. ignore HTTP 404
    `
      error_handler:
        response_filters:
          - http_codes: [404]
            action: IGNORE
    `
    5. retry if error message contains `retrythisrequest!` substring
    `
        error_handler:
          response_filters:
            - error_message_contain: "retrythisrequest!"
              action: IGNORE
    `
    6. retry if 'code' is a field present in the response body
    `
        error_handler:
          response_filters:
            - predicate: "{{ 'code' in response }}"
              action: IGNORE
    `

    7. ignore 429 and retry on 404
    `
        error_handler:
        - http_codes: [429]
          action: IGNORE
        - http_codes: [404]
          action: RETRY
    `

    Attributes:
        response_filters (Optional[List[HttpResponseFilter]]): response filters to iterate on
        max_retries (Optional[int]): maximum retry attempts
        backoff_strategies (Optional[List[BackoffStrategy]]): list of backoff strategies to use to determine how long
        to wait before retrying
    
 */
export type DefaultErrorHandler = ErrorHandler & DefaultErrorHandlerAllOf;

export type CompositeErrorHandlerAllOfErrorHandlersItem = CompositeErrorHandler | DefaultErrorHandler;

export type CompositeErrorHandlerAllOf = {
  error_handlers: CompositeErrorHandlerAllOfErrorHandlersItem[];
};

/**
 * 
    Error handler that sequentially iterates over a list of `ErrorHandler`s

    Sample config chaining 2 different retriers:
        error_handler:
          type: "CompositeErrorHandler"
          error_handlers:
            - response_filters:
                - predicate: "{{ 'codase' in response }}"
                  action: RETRY
              backoff_strategies:
                - type: "ConstantBackoff"
                  backoff_time_in_seconds: 5
            - response_filters:
                - http_codes: [403]
                  action: RETRY
              backoff_strategies:
                - type: "ConstantBackoff"
                  backoff_time_in_seconds: 10
    Attributes:
        error_handlers (List[ErrorHandler]): list of error handlers
    
 */
export type CompositeErrorHandler = ErrorHandler & CompositeErrorHandlerAllOf;

export type SessionTokenAuthenticatorAllOfConfig = { [key: string]: any };

export type SessionTokenAuthenticatorAllOfHeader = InterpolatedString | string;

export type SessionTokenAuthenticatorAllOfPassword = InterpolatedString | string;

export type SessionTokenAuthenticatorAllOfUsername = InterpolatedString | string;

export type SessionTokenAuthenticatorAllOfSessionToken = InterpolatedString | string;

export type SessionTokenAuthenticatorAllOfApiUrl = InterpolatedString | string;

export type SessionTokenAuthenticatorAllOf = {
  api_url: SessionTokenAuthenticatorAllOfApiUrl;
  session_token?: SessionTokenAuthenticatorAllOfSessionToken;
  username?: SessionTokenAuthenticatorAllOfUsername;
  password?: SessionTokenAuthenticatorAllOfPassword;
  header: SessionTokenAuthenticatorAllOfHeader;
  config?: SessionTokenAuthenticatorAllOfConfig;
};

export type SessionTokenAuthenticator = DeclarativeAuthenticator & SessionTokenAuthenticatorAllOf;

/**
 * 
    Builds auth based off the basic authentication scheme as defined by RFC 7617, which transmits credentials as USER ID/password pairs, encoded using base64
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic_authentication_scheme

    The header is of the form
    `"Authorization": "Basic <encoded_credentials>"`

    Attributes:
        username (Union[InterpolatedString, str]): The username
        config (Config): The user-provided configuration as specified by the source's spec
        password (Union[InterpolatedString, str]): The password
        options (Mapping[str, Any]): Additional runtime parameters to be used for string interpolation
    
 */
export type BasicHttpAuthenticator = DeclarativeAuthenticator & BasicHttpAuthenticatorAllOf;

export type BasicHttpAuthenticatorAllOfPassword = InterpolatedString | string;

export type BasicHttpAuthenticatorAllOfConfig = { [key: string]: any };

export type BasicHttpAuthenticatorAllOfUsername = InterpolatedString | string;

export type BasicHttpAuthenticatorAllOf = {
  username: BasicHttpAuthenticatorAllOfUsername;
  config: BasicHttpAuthenticatorAllOfConfig;
  password?: BasicHttpAuthenticatorAllOfPassword;
};

/**
 * 
    Authenticator that sets the Authorization header on the HTTP requests sent.

    The header is of the form:
    `"Authorization": "Bearer <token>"`

    Attributes:
        api_token (Union[InterpolatedString, str]): The bearer token
        config (Config): The user-provided configuration as specified by the source's spec
        options (Mapping[str, Any]): Additional runtime parameters to be used for string interpolation
    
 */
export type BearerAuthenticator = DeclarativeAuthenticator & BearerAuthenticatorAllOf;

export type BearerAuthenticatorAllOfConfig = { [key: string]: any };

export type BearerAuthenticatorAllOfApiToken = InterpolatedString | string;

export type BearerAuthenticatorAllOf = {
  api_token: BearerAuthenticatorAllOfApiToken;
  config: BearerAuthenticatorAllOfConfig;
};

/**
 * 
    ApiKeyAuth sets a request header on the HTTP requests sent.

    The header is of the form:
    `"<header>": "<token>"`

    For example,
    `ApiKeyAuthenticator("Authorization", "Bearer hello")`
    will result in the following header set on the HTTP request
    `"Authorization": "Bearer hello"`

    Attributes:
        header (Union[InterpolatedString, str]): Header key to set on the HTTP requests
        api_token (Union[InterpolatedString, str]): Header value to set on the HTTP requests
        config (Config): The user-provided configuration as specified by the source's spec
        options (Mapping[str, Any]): Additional runtime parameters to be used for string interpolation
    
 */
export type ApiKeyAuthenticator = DeclarativeAuthenticator & ApiKeyAuthenticatorAllOf;

export type ApiKeyAuthenticatorAllOfConfig = { [key: string]: any };

export type ApiKeyAuthenticatorAllOfApiToken = InterpolatedString | string;

export type ApiKeyAuthenticatorAllOfHeader = InterpolatedString | string;

export type ApiKeyAuthenticatorAllOf = {
  header: ApiKeyAuthenticatorAllOfHeader;
  api_token: ApiKeyAuthenticatorAllOfApiToken;
  config: ApiKeyAuthenticatorAllOfConfig;
};

/**
 * 
    Generates OAuth2.0 access tokens from an OAuth2.0 refresh token and client credentials based on
    a declarative connector configuration file. Credentials can be defined explicitly or via interpolation
    at runtime. The generated access token is attached to each request via the Authorization header.

    Attributes:
        token_refresh_endpoint (Union[InterpolatedString, str]): The endpoint to refresh the access token
        client_id (Union[InterpolatedString, str]): The client id
        client_secret (Union[InterpolatedString, str]): Client secret
        refresh_token (Union[InterpolatedString, str]): The token used to refresh the access token
        access_token_name (Union[InterpolatedString, str]): THe field to extract access token from in the response
        expires_in_name (Union[InterpolatedString, str]): The field to extract expires_in from in the response
        config (Mapping[str, Any]): The user-provided configuration as specified by the source's spec
        scopes (Optional[List[str]]): The scopes to request
        token_expiry_date (Optional[Union[InterpolatedString, str]]): The access token expiration date
        refresh_request_body (Optional[Mapping[str, Any]]): The request body to send in the refresh request
        grant_type: The grant_type to request for access_token
    
 */
export type DeclarativeOauth2Authenticator = DeclarativeAuthenticator & DeclarativeOauth2AuthenticatorAllOf;

export type DeclarativeOauth2AuthenticatorAllOfGrantType = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfRefreshRequestBody = { [key: string]: any };

export type DeclarativeOauth2AuthenticatorAllOfExpiresInName = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfAccessTokenName = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfTokenExpiryDate = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfConfig = { [key: string]: any };

export type DeclarativeOauth2AuthenticatorAllOfRefreshToken = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfClientSecret = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfClientId = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOfTokenRefreshEndpoint = InterpolatedString | string;

export type DeclarativeOauth2AuthenticatorAllOf = {
  token_refresh_endpoint: DeclarativeOauth2AuthenticatorAllOfTokenRefreshEndpoint;
  client_id: DeclarativeOauth2AuthenticatorAllOfClientId;
  client_secret: DeclarativeOauth2AuthenticatorAllOfClientSecret;
  refresh_token: DeclarativeOauth2AuthenticatorAllOfRefreshToken;
  config: DeclarativeOauth2AuthenticatorAllOfConfig;
  scopes?: string[];
  token_expiry_date?: DeclarativeOauth2AuthenticatorAllOfTokenExpiryDate;
  _token_expiry_date?: unknown;
  access_token_name?: DeclarativeOauth2AuthenticatorAllOfAccessTokenName;
  expires_in_name?: DeclarativeOauth2AuthenticatorAllOfExpiresInName;
  refresh_request_body?: DeclarativeOauth2AuthenticatorAllOfRefreshRequestBody;
  grant_type?: DeclarativeOauth2AuthenticatorAllOfGrantType;
};

/**
 * 
    Interface used to associate which authenticators can be used as part of the declarative framework
    
 */
export interface DeclarativeAuthenticator {
  [key: string]: any;
}

export type NoAuthAllOf = { [key: string]: any };

/**
 * NoAuth(options: dataclasses.InitVar[typing.Mapping[str, typing.Any]])
 */
export type NoAuth = DeclarativeAuthenticator & NoAuthAllOf;

/**
 * 
    Defines the request options to set on an outgoing HTTP request

    Options can be passed by
    - request parameter
    - request headers
    - body data
    - json content
    
 */
export interface RequestOptionsProvider {
  [key: string]: any;
}

export type InterpolatedRequestOptionsProviderAllOfRequestBodyJsonAnyOf = { [key: string]: string };

export type InterpolatedRequestOptionsProviderAllOfRequestBodyJson =
  | InterpolatedRequestOptionsProviderAllOfRequestBodyJsonAnyOf
  | string;

export type InterpolatedRequestOptionsProviderAllOfRequestBodyDataAnyOf = { [key: string]: string };

export type InterpolatedRequestOptionsProviderAllOfRequestBodyData =
  | InterpolatedRequestOptionsProviderAllOfRequestBodyDataAnyOf
  | string;

export type InterpolatedRequestOptionsProviderAllOfRequestHeadersAnyOf = { [key: string]: string };

export type InterpolatedRequestOptionsProviderAllOfRequestHeaders =
  | InterpolatedRequestOptionsProviderAllOfRequestHeadersAnyOf
  | string;

export type InterpolatedRequestOptionsProviderAllOfRequestParametersAnyOf = { [key: string]: string };

export type InterpolatedRequestOptionsProviderAllOfRequestParameters =
  | InterpolatedRequestOptionsProviderAllOfRequestParametersAnyOf
  | string;

export type InterpolatedRequestOptionsProviderAllOfConfig = { [key: string]: any };

export type InterpolatedRequestOptionsProviderAllOf = {
  config?: InterpolatedRequestOptionsProviderAllOfConfig;
  request_parameters?: InterpolatedRequestOptionsProviderAllOfRequestParameters;
  request_headers?: InterpolatedRequestOptionsProviderAllOfRequestHeaders;
  request_body_data?: InterpolatedRequestOptionsProviderAllOfRequestBodyData;
  request_body_json?: InterpolatedRequestOptionsProviderAllOfRequestBodyJson;
};

/**
 * 
    Defines the request options to set on an outgoing HTTP request by evaluating `InterpolatedMapping`s

    Attributes:
        config (Config): The user-provided configuration as specified by the source's spec
        request_parameters (Union[str, Mapping[str, str]]): The request parameters to set on an outgoing HTTP request
        request_headers (Union[str, Mapping[str, str]]): The request headers to set on an outgoing HTTP request
        request_body_data (Union[str, Mapping[str, str]]): The body data to set on an outgoing HTTP request
        request_body_json (Union[str, Mapping[str, str]]): The json content to set on an outgoing HTTP request
    
 */
export type InterpolatedRequestOptionsProvider = RequestOptionsProvider & InterpolatedRequestOptionsProviderAllOf;

/**
 * 
    Wrapper around a raw string to be interpolated with the Jinja2 templating engine

    Attributes:
        string (str): The string to evalute
        default (Optional[str]): The default value to return if the evaluation returns an empty string
        options (Mapping[str, Any]): Additional runtime parameters to be used for string interpolation
    
 */
export interface InterpolatedString {
  string: string;
  default?: string;
}

export type HttpRequesterAllOfErrorHandler = CompositeErrorHandler | DefaultErrorHandler;

export type HttpRequesterAllOfAuthenticator =
  | NoAuth
  | DeclarativeOauth2Authenticator
  | ApiKeyAuthenticator
  | BearerAuthenticator
  | BasicHttpAuthenticator
  | SessionTokenAuthenticator;

export type HttpRequesterAllOfHttpMethod = string | "GET" | "POST";

export type HttpRequesterAllOfConfig = { [key: string]: any };

export type HttpRequesterAllOfPath = InterpolatedString | string;

export type HttpRequesterAllOfUrlBase = InterpolatedString | string;

export type HttpRequesterAllOf = {
  name: string;
  url_base: HttpRequesterAllOfUrlBase;
  path: HttpRequesterAllOfPath;
  config: HttpRequesterAllOfConfig;
  http_method?: HttpRequesterAllOfHttpMethod;
  request_options_provider?: InterpolatedRequestOptionsProvider;
  authenticator?: HttpRequesterAllOfAuthenticator;
  error_handler?: HttpRequesterAllOfErrorHandler;
};

/**
 * 
    Default implementation of a Requester

    Attributes:
        name (str): Name of the stream. Only used for request/response caching
        url_base (Union[InterpolatedString, str]): Base url to send requests to
        path (Union[InterpolatedString, str]): Path to send requests to
        http_method (Union[str, HttpMethod]): HTTP method to use when sending requests
        request_options_provider (Optional[InterpolatedRequestOptionsProvider]): request option provider defining the options to set on outgoing requests
        authenticator (DeclarativeAuthenticator): Authenticator defining how to authenticate to the source
        error_handler (Optional[ErrorHandler]): Error handler defining how to detect and handle errors
        config (Config): The user-provided configuration as specified by the source's spec
    
 */
export type HttpRequester = Requester & HttpRequesterAllOf;

/**
 * 
    Retrieves records by synchronously sending requests to fetch records.

    The retriever acts as an orchestrator between the requester, the record selector, the paginator, and the stream slicer.

    For each stream slice, submit requests until there are no more pages of records to fetch.

    This retriever currently inherits from HttpStream to reuse the request submission and pagination machinery.
    As a result, some of the parameters passed to some methods are unused.
    The two will be decoupled in a future release.

    Attributes:
        stream_name (str): The stream's name
        stream_primary_key (Optional[Union[str, List[str], List[List[str]]]]): The stream's primary key
        requester (Requester): The HTTP requester
        record_selector (HttpSelector): The record selector
        paginator (Optional[Paginator]): The paginator
        stream_slicer (Optional[StreamSlicer]): The stream slicer
        options (Mapping[str, Any]): Additional runtime parameters to be used for string interpolation
    
 */
export type SimpleRetriever = Retriever & SimpleRetrieverAllOf;

export type SimpleRetrieverAllOfStreamSlicer =
  | CartesianProductStreamSlicer
  | DatetimeStreamSlicer
  | ListStreamSlicer
  | SingleSlice
  | SubstreamSlicer;

export type SimpleRetrieverAllOfPaginator = DefaultPaginator | NoPagination;

export type SimpleRetrieverAllOfPrimaryKey = string[] | string[][] | string;

export type _SimpleRetrieverAllOfName = InterpolatedString | string;

export type SimpleRetrieverAllOfConfig = { [key: string]: any };

export type SimpleRetrieverAllOf = {
  requester: HttpRequester;
  record_selector: RecordSelector;
  config: SimpleRetrieverAllOfConfig;
  name?: string;
  _name?: _SimpleRetrieverAllOfName;
  primary_key?: SimpleRetrieverAllOfPrimaryKey;
  _primary_key?: string;
  paginator?: SimpleRetrieverAllOfPaginator;
  stream_slicer?: SimpleRetrieverAllOfStreamSlicer;
};

export type DeclarativeStreamTransformationsItem = AddFields | RemoveFields;

export type DeclarativeStreamStreamCursorField = string[] | string;

export type _DeclarativeStreamSchemaLoader = JsonFileSchemaLoader | DefaultSchemaLoader | InlineSchemaLoader;

export type DeclarativeStreamSchemaLoader = JsonFileSchemaLoader | DefaultSchemaLoader | InlineSchemaLoader;

export type DeclarativeStreamPrimaryKey = string[] | string[][] | string;

export type DeclarativeStreamConfig = { [key: string]: any };

/**
 * 
    DeclarativeStream is a Stream that delegates most of its logic to its schema_load and retriever

    Attributes:
        name (str): stream name
        primary_key (Optional[Union[str, List[str], List[List[str]]]]): the primary key of the stream
        schema_loader (SchemaLoader): The schema loader
        retriever (Retriever): The retriever
        config (Config): The user-provided configuration as specified by the source's spec
        stream_cursor_field (Optional[List[str]]): The cursor field
        transformations (List[RecordTransformation]): A list of transformations to be applied to each output record in the
        stream. Transformations are applied in the order in which they are defined.
        checkpoint_interval (Optional[int]): How often the stream will checkpoint state (i.e: emit a STATE message)
    
 */
export interface DeclarativeStream {
  retriever: SimpleRetriever;
  config: DeclarativeStreamConfig;
  name?: string;
  primary_key?: DeclarativeStreamPrimaryKey;
  schema_loader?: DeclarativeStreamSchemaLoader;
  _name?: string;
  _primary_key?: string;
  _schema_loader?: _DeclarativeStreamSchemaLoader;
  stream_cursor_field?: DeclarativeStreamStreamCursorField;
  transformations?: DeclarativeStreamTransformationsItem[];
  checkpoint_interval?: number;
}

/**
 * 
    Checks the connections by trying to read records from one or many of the streams selected by the developer

    Attributes:
        stream_name (List[str]): name of streams to read records from
    
 */
export interface CheckStream {
  stream_names: string[];
}

/**
 * ConcreteDeclarativeSource(version: str, check: airbyte_cdk.sources.declarative.checks.check_stream.CheckStream, streams: List[airbyte_cdk.sources.declarative.declarative_stream.DeclarativeStream])
 */
export interface ConfigComponentSchema {
  version: string;
  check: CheckStream;
  streams: DeclarativeStream[];
}

export type ConnectorManifest = ConfigComponentSchema;
